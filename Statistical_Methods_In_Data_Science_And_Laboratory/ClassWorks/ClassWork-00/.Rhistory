# Load libraries
library(jpeg)
library(waveslim)
# Load grayscale image
img <- readJPEG("./grayscale_images/Lenna.jpg")
####
# We asked the chatbot how to convert an RGB image to grayscale and how to pad an image so its size becomes a power of 2 for the wavelet transform.
####
# If image is RGB, convert to grayscale
if (length(dim(img)) == 3) {
img <- 0.299 * img[,,1] + 0.587 * img[,,2] + 0.114 * img[,,3]
}
# Pad image so both dimensions are powers of 2 (needed for wavelets)
pad_to_pow2 <- function(img) {
nr <- nrow(img)
nc <- ncol(img)
nr2 <- 2^ceiling(log2(nr))
nc2 <- 2^ceiling(log2(nc))
padded <- matrix(0, nr2, nc2)
padded[1:nr, 1:nc] <- img
return(padded)
}
X <- pad_to_pow2(img)
####
# We asked the chatbot how to apply a 2D Haar wavelet transform in R and how to extract the coefficients (like LH2, HL2, or HH2) from the result.
####
# Apply 2D Haar wavelet transform (3 levels)
dwt <- dwt.2d(X, wf = "haar", J = 3, boundary = "periodic")
# Extract detail coefficients at level 2 (try LH2, else HL2 or HH2)
get_subband <- function(dwt, level = 2) {
for (band in c("LH", "HL", "HH")) {
name <- paste0(band, level)
if (name %in% names(dwt)) {
return(as.matrix(dwt[[name]]))
}
}
stop("Level 2 detail subband not found.")
}
coef <- get_subband(dwt)
####
# Here we asked gpt that how to turn a matrix of wavelet coefficients to numeric vector and plot the distribution to check if it is Gaussian.
####
# Flatten matrix to vector, remove NaN/Inf
vec_clean <- function(mat) {
v <- as.numeric(mat)
v[is.finite(v)]
}
# Plot histogram and QQ-plot of raw coefficients
par(mfrow = c(2,2))
hist(vec_clean(coef), breaks = 50, col = "lightblue", main = "Raw Coeffs")
# Load libraries
library(jpeg)
library(waveslim)
# Load grayscale image
img <- readJPEG("./grayscale_images/Lenna.jpg")
####
# We asked the chatbot how to convert an RGB image to grayscale and how to pad an image so its size becomes a power of 2 for the wavelet transform.
####
# If image is RGB, convert to grayscale
if (length(dim(img)) == 3) {
img <- 0.299 * img[,,1] + 0.587 * img[,,2] + 0.114 * img[,,3]
}
# Pad image so both dimensions are powers of 2 (needed for wavelets)
pad_to_pow2 <- function(img) {
nr <- nrow(img)
nc <- ncol(img)
nr2 <- 2^ceiling(log2(nr))
nc2 <- 2^ceiling(log2(nc))
padded <- matrix(0, nr2, nc2)
padded[1:nr, 1:nc] <- img
return(padded)
}
X <- pad_to_pow2(img)
dwt <- dwt.2d(X, wf = "haar", J = 3, boundary = "periodic")
# Extract detail coefficients at level 2 (try LH2, else HL2 or HH2)
get_subband <- function(dwt, level = 2) {
for (band in c("LH", "HL", "HH")) {
name <- paste0(band, level)
if (name %in% names(dwt)) {
return(as.matrix(dwt[[name]]))
}
}
stop("Level 2 detail subband not found.")
}
coef <- get_subband(dwt)
vec_clean <- function(mat) {
v <- as.numeric(mat)
v[is.finite(v)]
}
# Plot histogram and QQ-plot of raw coefficients
par(mfrow = c(2,2))
hist(vec_clean(coef), breaks = 50, col = "lightblue", main = "Raw Coeffs")
# Flatten matrix to vector, remove NaN/Inf
vec_clean <- function(mat) {
v <- as.numeric(mat)
v[is.finite(v)]
}
# Plot histogram and QQ-plot of raw coefficients
par(mfrow = c(2,2))
hist(vec_clean(coef), breaks = 50, col = "lightblue", main = "Raw Coeffs")
# Flatten matrix to vector, remove NaN/Inf
vec_clean <- function(mat) {
v <- as.numeric(mat)
v[is.finite(v)]
}
# Plot histogram and QQ-plot of raw coefficients
par(mfrow = c(2,2))
hist(vec_clean(coef), breaks = 50, col = "lightblue", main = "Raw Coeffs")
qqnorm(vec_clean(coef)); qqline(vec_clean(coef), col = "red")
####
# We asked gpt to see how to normalize a wavelet coefficient matrix block-by-block using local RMS, like it's done in GSM models.
# Then we wanted to see if the normalization makes the distribution more Gaussian, so we tried to plot a histogram and Q-Q plot after normalization.
####
# Normalize using local RMS per 8x8 block
normalize_blocks <- function(mat, block = 8) {
out <- mat
for (i in seq(1, nrow(mat), by = block)) {
for (j in seq(1, ncol(mat), by = block)) {
blk <- mat[i:min(i+block-1, nrow(mat)), j:min(j+block-1, ncol(mat))]
scale <- sqrt(mean(blk^2)) + 1e-6  # avoid dividing by zero
out[i:min(i+block-1, nrow(mat)), j:min(j+block-1, ncol(mat))] <- blk / scale
}
}
return(out)
}
coef_norm <- normalize_blocks(coef)
####
# We asked gpt to see how to normalize a wavelet coefficient matrix block-by-block using local RMS, like it's done in GSM models.
# Then we wanted to see if the normalization makes the distribution more Gaussian, so we tried to plot a histogram and Q-Q plot after normalization.
####
# Normalize using local RMS per 8x8 block
normalize_blocks <- function(mat, block = 8) {
out <- mat
for (i in seq(1, nrow(mat), by = block)) {
for (j in seq(1, ncol(mat), by = block)) {
blk <- mat[i:min(i+block-1, nrow(mat)), j:min(j+block-1, ncol(mat))]
scale <- sqrt(mean(blk^2)) + 1e-6  # avoid dividing by zero
out[i:min(i+block-1, nrow(mat)), j:min(j+block-1, ncol(mat))] <- blk / scale
}
}
return(out)
}
coef_norm <- normalize_blocks(coef)
# Plot histogram and QQ-plot after normalization
par(mfrow = c(2,2))
hist(vec_clean(coef_norm), breaks = 50, col = "lightgreen", main = "Normalized Coeffs")
qqnorm(vec_clean(coef_norm)); qqline(vec_clean(coef_norm), col = "red")
# Scatter plots: original vs. neighbor to the right
par(mfrow = c(1,2))
if (ncol(coef) > 1) {
plot(coef[, -ncol(coef)], coef[, -1], pch = 16, cex = 0.3,
xlab = "coef(i,j)", ylab = "coef(i,j+1)", main = "Neighbor (raw)")
}
if (ncol(coef_norm) > 1) {
plot(coef_norm[, -ncol(coef_norm)], coef_norm[, -1], pch = 16, cex = 0.3,
xlab = "nu(i,j)", ylab = "nu(i,j+1)", main = "Neighbor (normalized)")
}
# Scatter plots: original vs. neighbor to the right
par(mfrow = c(1,2))
if (ncol(coef) > 1) {
plot(coef[, -ncol(coef)], coef[, -1], pch = 16, cex = 0.3,
xlab = "coef(i,j)", ylab = "coef(i,j+1)", main = "Neighbor (raw)")
}
if (ncol(coef_norm) > 1) {
plot(coef_norm[, -ncol(coef_norm)], coef_norm[, -1], pch = 16, cex = 0.3,
xlab = "nu(i,j)", ylab = "nu(i,j+1)", main = "Neighbor (normalized)")
}
?dunif
set.seed(3435)
M <- 1000
Xsamp <- runif(M, min = -1, max = +1)
hist(Xamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)"),
hist(Xamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
hist(Xamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(duif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
curve(duif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
Xsamp <- runif(M, min = -1, max = +1)
Ysamp = (Xsamp)^2
dtrans <- function(x) 0.5*(y)^(-0.5)
par(mfrow = c(2,1))
# G21
# Team Leader: Arman Feili
# Team Members: Milad Torabi, Sohrab Seyyedi Parsa
# Q1
data <- read.csv("./Country-data/Country-data.csv")
x <- data$life_expec
summary(x)
hist(x,
breaks = 20,
main = "life Expectancy",
xlab = "Years"
)
set.seed(3435)
M <- 1000
Xsamp <- runif(M, min = -1, max = +1)
Ysamp = (Xsamp)^2
dtrans <- function(x) 0.5*(y)^(-0.5)
par(mfrow = c(2,1))
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
set.seed(3435)
M <- 1000
Xsamp <- runif(M, min = -1, max = +1)
Ysamp = (Xsamp)^2
dtrans <- function(x) 0.5*(y)^(-0.5)
par(mfrow = c(2,1))
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
set.seed(3435)
M <- 1000
Xsamp <- runif(M, min = -1, max = +1)
Ysamp = (Xsamp)^2
dtrans <- function(x) 0.5*(y)^(-0.5)
par(mfrow = c(2,1))
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Xsamp, prob=T,
border="white",
col="orange2",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from Unif(-1,+1)",
xlab="x",
breaks = 25)
curve(dunif(x, -1,+1), add = T,
lwd = 4,
col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
hist(Ysamp, prob=T,
border="white",
col="blue",
main = "Samples from the transformed R.V.",
xlab="x",
breaks = 25)
set.seed(3435)
M <- 1000
Xsamp <- runif(M, min = -1, max = +1)
Ysamp = (Xsamp)^2
# Correct density function for Y = X^2, X ~ U(-1,1)
dtrans <- function(y) 1 / (2 * sqrt(y))
par(mfrow = c(2,1))
# Plot for X
hist(Xsamp, prob=TRUE, border="white", col="orange2",
main = "Samples from Unif(-1,+1)", xlab="x", breaks = 25)
curve(dunif(x, -1,+1), add = TRUE, lwd = 4, col = "red3")
rug(Xsamp, col = rgb(0,0,0,.3))
# Plot for Y
hist(Ysamp, prob=TRUE, border="white", col="blue",
main = "Samples from Y = X^2", xlab="y", breaks = 25)
curve(dtrans(x), from=0.001, to=1, add = TRUE, lwd = 4, col = "red3")  # Avoid sqrt(0)
rug(Ysamp, col = rgb(0,0,0,.3))
?rnorm
?rchisq
z ind W
#       z ind W
# Pick nu
nu <- 2
?rnorm
?rchisq
set.seed(4321)
M <- 5000
Zsamp <- rnorm(M, 0, 1)
Wsamp <- rchisq(M, df = nu)
Tsamp <- Zsamp/sqrt(Wsamp/nu)
# Plot
hist(Tsamp, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 25)
curve(dtrans(x), from=0.001, to=1, add = TRUE, lwd = 4, col = "red3")  # Avoid sqrt(0)
rug(Ysamp, col = rgb(0,0,0,.3))
curve(dt(x), from=0.001, to=1, add = TRUE, lwd = 4, col = "red3")  # Avoid sqrt(0)
sub = paste("Degrees of Freedom = ", nu),
hist(Tsamp, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 25)
curve(dt(x), from=0.001, to=1, add = TRUE, lwd = 4, col = "red3")  # Avoid sqrt(0)
# Plot
hist(Tsamp, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 25)
curve(dt(x), from=0.001, to=1, add = TRUE, lwd = 4, col = "red3")  # Avoid sqrt(0)
set.seed(4321)
M <- 5000
Zsamp <- rnorm(M, 0, 1)
Wsamp <- rchisq(M, df = nu)
Tsamp <- Zsamp/sqrt(Wsamp/nu)
# Plot
hist(Tsamp, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 25)
curve(dt(x, df = nu), add = T, lwd = 4, col = "cyan3")  # Avoid sqrt(0)
# rug(Tsamp, col = rgb(0,0,0,.3))
rug(Tsamp)
set.seed(4321)
M <- 5000
Zsamp <- rnorm(M, 0, 1)
Wsamp <- rchisq(M, df = nu)
Tsamp <- Zsamp/sqrt(Wsamp/nu)
# Plot
hist(Tsamp, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 50)
curve(dt(x, df = nu), add = T, lwd = 4, col = "cyan3")  # Avoid sqrt(0)
# rug(Tsamp, col = rgb(0,0,0,.3))
rug(Tsamp)
box()
set.seed(4321)
M <- 5000
Zsamp <- rnorm(M, 0, 1)
Wsamp <- rchisq(M, df = nu)
Tsamp <- Zsamp/sqrt(Wsamp/nu)
# Plot
Tsamp_sel <- Tsamp[abs(Tsamp) < 20]
hist(Tsamp_sel, prob=TRUE, border="white", col="navy",
main = "Samples from a Student-t?",
sub = paste("Degrees of Freedom = ", nu),
xlab="y", breaks = 50)
curve(dt(x, df = nu), add = T, lwd = 4, col = "cyan3")  # Avoid sqrt(0)
# rug(Tsamp, col = rgb(0,0,0,.3))
rug(Tsamp)
box()
